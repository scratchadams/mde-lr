//! Alert management for the MDE API.
//!
//! This module covers the "Alerts" endpoint family — reading and updating
//! security alerts generated by Microsoft Defender for Endpoint.
//!
//! ## Endpoints
//!
//! | Function | API Path | Permission |
//! |----------|----------|------------|
//! | [`list_alerts`] | GET `/api/alerts` | `Alert.ReadWrite.All` |
//! | [`get_alert`] | GET `/api/alerts/{alert_id}` | `Alert.ReadWrite.All` |
//! | [`update_alert`] | PATCH `/api/alerts/{alert_id}` | `Alert.ReadWrite.All` |
//! | [`batch_update_alerts`] | PATCH `/api/alerts/batchUpdate` | `Alert.ReadWrite.All` |
//!
//! ## OData filtering
//!
//! [`list_alerts`] supports OData V4 `$filter` expressions on fields like
//! `alertCreationTime`, `status`, `severity`, `category`, `assignedTo`, etc.
//! Pass `None` to retrieve all alerts (up to the 10,000 page limit).
//!
//! ## Rate limits
//!
//! Most alert endpoints follow the standard 100 calls/min limit. The
//! [`batch_update_alerts`] endpoint has a stricter limit of 10 calls/min
//! and 500 calls/hour.
//!
//! ## References
//!
//! - <https://learn.microsoft.com/en-us/defender-endpoint/api/get-alerts>
//! - <https://learn.microsoft.com/en-us/defender-endpoint/api/update-alert>
//! - <https://learn.microsoft.com/en-us/defender-endpoint/api/batch-update-alerts>

use serde::{Deserialize, Serialize};

use crate::client::MdeClient;
use crate::machines::ODataList;

// ── Response types ──────────────────────────────────────────────────────

/// A security alert as returned by the MDE API.
///
/// Field names use camelCase to match the MDE API contract. Most fields
/// are optional because the API may omit them depending on alert state,
/// detection source, or tenant configuration.
///
/// The `evidence` field is represented as raw JSON values because evidence
/// objects are polymorphic (User, Process, File, etc.) with different
/// fields per entity type. Full typing is deferred until specific evidence
/// processing is needed.
///
/// Reference: <https://learn.microsoft.com/en-us/defender-endpoint/api/alerts>
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct Alert {
    /// Unique identifier for this alert.
    pub id: String,

    /// Alert title — a short description of the threat detected.
    #[serde(default)]
    pub title: Option<String>,

    /// Detailed description of the alert and the threat behavior.
    #[serde(default)]
    pub description: Option<String>,

    /// ISO 8601 timestamp of when the alert was created.
    #[serde(default)]
    pub alert_creation_time: Option<String>,

    /// ISO 8601 timestamp of the first event that triggered the alert.
    #[serde(default)]
    pub first_event_time: Option<String>,

    /// ISO 8601 timestamp of the last event related to this alert.
    #[serde(default)]
    pub last_event_time: Option<String>,

    /// ISO 8601 timestamp of the last update to this alert.
    #[serde(default)]
    pub last_update_time: Option<String>,

    /// ISO 8601 timestamp of when the alert was resolved (if applicable).
    #[serde(default)]
    pub resolved_time: Option<String>,

    /// ID of the incident this alert belongs to.
    #[serde(default)]
    pub incident_id: Option<i64>,

    /// ID of the automated investigation (if any) triggered by this alert.
    #[serde(default)]
    pub investigation_id: Option<i64>,

    /// State of the automated investigation: `Unknown`, `Terminated`,
    /// `SuccessfullyRemediated`, `Benign`, `Failed`, `PartiallyRemediated`,
    /// `Running`, `PendingApproval`, `PendingResource`, `PartiallyInvestigated`,
    /// `TerminatedByUser`, `TerminatedBySystem`, `Queued`, `InnerFailure`,
    /// `PreexistingAlert`, `UnsupportedOs`, `UnsupportedAlertType`, or
    /// `SuppressedAlert`.
    #[serde(default)]
    pub investigation_state: Option<String>,

    /// User or mailbox assigned to this alert for triage.
    #[serde(default)]
    pub assigned_to: Option<String>,

    /// Alert severity: `UnSpecified`, `Informational`, `Low`, `Medium`, or `High`.
    #[serde(default)]
    pub severity: Option<String>,

    /// Alert status: `Unknown`, `New`, `InProgress`, or `Resolved`.
    #[serde(default)]
    pub status: Option<String>,

    /// Alert classification: `TruePositive`, `InformationalExpectedActivity`,
    /// or `FalsePositive`. Set during triage to indicate whether the alert
    /// is a genuine threat.
    #[serde(default)]
    pub classification: Option<String>,

    /// Alert determination — provides more detail on the classification.
    /// Valid values depend on the classification:
    /// - TruePositive: `MultiStagedAttack`, `MaliciousUserActivity`,
    ///   `CompromisedUser`, `Malware`, `Phishing`, `UnwantedSoftware`, `Other`
    /// - InformationalExpectedActivity: `SecurityTesting`,
    ///   `LineOfBusinessApplication`, `ConfirmedActivity`, `Other`
    /// - FalsePositive: `NotMalicious`, `InsufficientData`, `Other`
    #[serde(default)]
    pub determination: Option<String>,

    /// Detection source that generated this alert (e.g. `"WindowsDefenderAtp"`,
    /// `"WindowsDefenderAv"`, `"CloudAppSecurity"`).
    #[serde(default)]
    pub detection_source: Option<String>,

    /// Identifier of the detector that produced this alert.
    #[serde(default)]
    pub detector_id: Option<String>,

    /// Threat category (e.g. `"Malware"`, `"Ransomware"`, `"Phishing"`).
    #[serde(default)]
    pub category: Option<String>,

    /// Name of the threat family (e.g. `"Mimikatz"`).
    #[serde(default)]
    pub threat_family_name: Option<String>,

    /// Full threat name (e.g. `"HackTool:Win32/Mimikatz!dha"`).
    #[serde(default)]
    pub threat_name: Option<String>,

    /// MDE device ID of the machine where the alert was generated.
    #[serde(default)]
    pub machine_id: Option<String>,

    /// DNS name of the device where the alert was generated.
    #[serde(default)]
    pub computer_dns_name: Option<String>,

    /// RBAC device group name for the affected device.
    #[serde(default)]
    pub rbac_group_name: Option<String>,

    /// Azure AD tenant ID that owns this alert.
    #[serde(default)]
    pub aad_tenant_id: Option<String>,

    /// MITRE ATT&CK techniques associated with this alert.
    #[serde(default)]
    pub mitre_techniques: Vec<String>,

    /// Comments added to this alert during triage.
    #[serde(default)]
    pub comments: Vec<AlertComment>,

    /// Evidence objects associated with this alert. Represented as raw
    /// JSON because evidence is polymorphic (User, Process, File, etc.)
    /// with different fields per entity type.
    #[serde(default)]
    pub evidence: Vec<serde_json::Value>,
}

/// A comment attached to an alert during triage or investigation.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct AlertComment {
    /// The comment text.
    #[serde(default)]
    pub comment: Option<String>,

    /// Identity of the user or app that created the comment.
    #[serde(default)]
    pub created_by: Option<String>,

    /// ISO 8601 timestamp of when the comment was created.
    #[serde(default)]
    pub created_time: Option<String>,
}

// ── Request types ───────────────────────────────────────────────────────

/// Request body for updating a single alert via `PATCH /api/alerts/{id}`.
///
/// All fields are optional — only include the fields you want to change.
/// At least one field should be present for the update to be meaningful.
/// Fields set to `None` are omitted from the JSON body, leaving the
/// corresponding alert property unchanged on the server.
///
/// Reference: <https://learn.microsoft.com/en-us/defender-endpoint/api/update-alert>
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct UpdateAlertRequest {
    /// New alert status: `"New"`, `"InProgress"`, or `"Resolved"`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,

    /// User or mailbox to assign this alert to (email address).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_to: Option<String>,

    /// Alert classification: `"TruePositive"`, `"InformationalExpectedActivity"`,
    /// or `"FalsePositive"`.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub classification: Option<String>,

    /// Alert determination — must match the classification (see [`Alert::determination`]
    /// for valid values per classification).
    #[serde(skip_serializing_if = "Option::is_none")]
    pub determination: Option<String>,

    /// Audit comment to add to the alert. Can be provided alone (without
    /// other updates) to just add a note.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}

/// Request body for batch-updating multiple alerts via
/// `PATCH /api/alerts/batchUpdate`.
///
/// The `alert_ids` field is required — it specifies which alerts to update.
/// All other fields are optional and apply the same update to every alert
/// in the batch.
///
/// **Rate limit**: This endpoint is limited to 10 calls/min and 500 calls/hour,
/// stricter than the standard 100 calls/min for other alert endpoints.
///
/// Reference: <https://learn.microsoft.com/en-us/defender-endpoint/api/batch-update-alerts>
#[derive(Debug, Serialize)]
#[serde(rename_all = "camelCase")]
pub struct BatchUpdateAlertsRequest {
    /// List of alert IDs to update. Required.
    pub alert_ids: Vec<String>,

    /// New alert status to apply to all alerts in the batch.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<String>,

    /// User or mailbox to assign all alerts to.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub assigned_to: Option<String>,

    /// Classification to apply to all alerts.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub classification: Option<String>,

    /// Determination to apply to all alerts.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub determination: Option<String>,

    /// Comment to add to all alerts.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub comment: Option<String>,
}

// ── Endpoint functions ──────────────────────────────────────────────────

/// Retrieves a paginated list of alerts visible to the tenant.
///
/// Pass an OData `$filter` expression to narrow results server-side, or
/// `None` to retrieve all alerts (up to the 10,000 page limit).
///
/// # Examples of filter expressions
///
/// - `"severity eq 'High'"` — only high-severity alerts.
/// - `"status eq 'New'"` — only unprocessed alerts.
/// - `"alertCreationTime gt 2026-01-01T00:00:00Z"` — alerts created after a date.
/// - `"assignedTo eq 'analyst@contoso.com'"` — alerts assigned to a specific user.
///
/// # Errors
///
/// - `MdeError::Api` — non-success HTTP status (e.g. 400 for a malformed
///   filter, 403 for insufficient permissions).
/// - `MdeError::Auth` — token acquisition or refresh failed.
/// - `MdeError::Network` — transport-level failure.
pub async fn list_alerts(
    client: &MdeClient,
    filter: Option<&str>,
) -> crate::error::Result<Vec<Alert>> {
    let path = match filter {
        Some(f) => format!("api/alerts?$filter={f}"),
        None => "api/alerts".to_string(),
    };
    let response: ODataList<Alert> = client.get(&path).await?;
    Ok(response.value)
}

/// Retrieves a single alert by its ID.
///
/// # Errors
///
/// - `MdeError::Api` — non-success HTTP status. A 404 means the alert
///   ID was not found or the caller lacks access.
/// - `MdeError::Auth` — token acquisition or refresh failed.
/// - `MdeError::Network` — transport-level failure.
pub async fn get_alert(client: &MdeClient, alert_id: &str) -> crate::error::Result<Alert> {
    let path = format!("api/alerts/{alert_id}");
    client.get(&path).await
}

/// Updates a single alert's properties (status, classification, assignment, etc.).
///
/// Returns the full updated [`Alert`] entity. Only the fields present in
/// the request body are modified — omitted fields remain unchanged.
///
/// # Errors
///
/// - `MdeError::Api` — non-success HTTP status. Common cases:
///   - 404: alert not found.
///   - 400: invalid field value (e.g. wrong determination for classification).
///   - 403: insufficient `Alert.ReadWrite.All` permission.
/// - `MdeError::Auth` — token acquisition or refresh failed.
/// - `MdeError::Network` — transport-level failure.
pub async fn update_alert(
    client: &MdeClient,
    alert_id: &str,
    update: &UpdateAlertRequest,
) -> crate::error::Result<Alert> {
    let path = format!("api/alerts/{alert_id}");
    client.patch(&path, update).await
}

/// Batch-updates multiple alerts in a single API call.
///
/// Applies the same update (status, classification, etc.) to every alert
/// specified in `request.alert_ids`. Returns `Ok(())` on success.
///
/// **Rate limit**: This endpoint is limited to 10 calls/min and 500 calls/hour,
/// significantly stricter than individual alert operations.
///
/// # Errors
///
/// - `MdeError::Api` — non-success HTTP status.
/// - `MdeError::Auth` — token acquisition or refresh failed.
/// - `MdeError::Network` — transport-level failure.
pub async fn batch_update_alerts(
    client: &MdeClient,
    request: &BatchUpdateAlertsRequest,
) -> crate::error::Result<()> {
    client
        .patch_no_content("api/alerts/batchUpdate", request)
        .await
}

#[cfg(test)]
mod tests {
    use super::*;

    // ── Alert deserialization ────────────────────────────────────────

    #[test]
    fn alert_deserializes_full_response() {
        // Exercises the Alert struct against a realistic API response
        // with most fields populated.
        let json = r#"{
            "id": "da637472900382838869_1364969609",
            "title": "Suspicious PowerShell command line",
            "description": "A suspicious PowerShell command was detected.",
            "alertCreationTime": "2026-01-15T10:30:00.1234567Z",
            "firstEventTime": "2026-01-15T10:28:00Z",
            "lastEventTime": "2026-01-15T10:29:00Z",
            "lastUpdateTime": "2026-01-15T11:00:00Z",
            "incidentId": 924518,
            "investigationId": 21,
            "investigationState": "SuccessfullyRemediated",
            "assignedTo": "analyst@contoso.com",
            "severity": "Medium",
            "status": "InProgress",
            "classification": "TruePositive",
            "determination": "Malware",
            "detectionSource": "WindowsDefenderAtp",
            "detectorId": "15e10f0f-05de-4928-9f49-8d0b0b9e64e5",
            "category": "SuspiciousActivity",
            "threatFamilyName": "Mimikatz",
            "threatName": "HackTool:Win32/Mimikatz!dha",
            "machineId": "1e5bc9d7e413ddd7902c2932e418702b84d0cc07",
            "computerDnsName": "host.contoso.com",
            "rbacGroupName": "The-A-Team",
            "aadTenantId": "00000000-0000-0000-0000-000000000001",
            "mitreTechniques": ["T1059.001", "T1003"],
            "comments": [
                {
                    "comment": "Investigating this alert",
                    "createdBy": "analyst@contoso.com",
                    "createdTime": "2026-01-15T11:00:00Z"
                }
            ],
            "evidence": [
                {"entityType": "Process", "processId": 1234}
            ]
        }"#;
        let alert: Alert = serde_json::from_str(json).unwrap();
        assert_eq!(alert.id, "da637472900382838869_1364969609");
        assert_eq!(
            alert.title.as_deref(),
            Some("Suspicious PowerShell command line")
        );
        assert_eq!(alert.severity.as_deref(), Some("Medium"));
        assert_eq!(alert.status.as_deref(), Some("InProgress"));
        assert_eq!(alert.classification.as_deref(), Some("TruePositive"));
        assert_eq!(alert.determination.as_deref(), Some("Malware"));
        assert_eq!(alert.incident_id, Some(924518));
        assert_eq!(alert.assigned_to.as_deref(), Some("analyst@contoso.com"));
        assert_eq!(
            alert.machine_id.as_deref(),
            Some("1e5bc9d7e413ddd7902c2932e418702b84d0cc07")
        );
        assert_eq!(alert.mitre_techniques, vec!["T1059.001", "T1003"]);
        assert_eq!(alert.comments.len(), 1);
        assert_eq!(
            alert.comments[0].comment.as_deref(),
            Some("Investigating this alert")
        );
        assert_eq!(alert.evidence.len(), 1);
    }

    #[test]
    fn alert_deserializes_minimal_response() {
        // The API may return sparse alerts. Only id is truly required;
        // all other fields should gracefully default.
        let json = r#"{"id": "alert-minimal-001"}"#;
        let alert: Alert = serde_json::from_str(json).unwrap();
        assert_eq!(alert.id, "alert-minimal-001");
        assert!(alert.title.is_none());
        assert!(alert.severity.is_none());
        assert!(alert.status.is_none());
        assert!(alert.mitre_techniques.is_empty());
        assert!(alert.comments.is_empty());
        assert!(alert.evidence.is_empty());
    }

    #[test]
    fn alert_ignores_unknown_fields() {
        // Forward compatibility: new API fields should not break deserialization.
        let json = r#"{
            "id": "alert-future",
            "title": "Future alert",
            "brandNewField": "surprise",
            "anotherNewThing": 42
        }"#;
        let alert: Alert = serde_json::from_str(json).unwrap();
        assert_eq!(alert.id, "alert-future");
        assert_eq!(alert.title.as_deref(), Some("Future alert"));
    }

    #[test]
    fn odata_list_deserializes_alert_collection() {
        // Verify that ODataList<Alert> works correctly since we reuse
        // the generic wrapper from the machines module.
        let json = r#"{
            "@odata.context": "https://api.security.microsoft.com/api/$metadata#Alerts",
            "value": [
                {"id": "alert-1", "severity": "High", "status": "New"},
                {"id": "alert-2", "severity": "Low", "status": "Resolved"}
            ]
        }"#;
        let list: ODataList<Alert> = serde_json::from_str(json).unwrap();
        assert_eq!(list.value.len(), 2);
        assert_eq!(list.value[0].id, "alert-1");
        assert_eq!(list.value[0].severity.as_deref(), Some("High"));
        assert_eq!(list.value[1].status.as_deref(), Some("Resolved"));
    }

    // ── UpdateAlertRequest serialization ─────────────────────────────

    #[test]
    fn update_alert_request_serializes_all_fields() {
        let req = UpdateAlertRequest {
            status: Some("Resolved".to_string()),
            assigned_to: Some("analyst@contoso.com".to_string()),
            classification: Some("TruePositive".to_string()),
            determination: Some("Malware".to_string()),
            comment: Some("Confirmed malware, remediated".to_string()),
        };
        let json = serde_json::to_value(&req).unwrap();
        assert_eq!(json["status"], "Resolved");
        assert_eq!(json["assignedTo"], "analyst@contoso.com");
        assert_eq!(json["classification"], "TruePositive");
        assert_eq!(json["determination"], "Malware");
        assert_eq!(json["comment"], "Confirmed malware, remediated");
    }

    #[test]
    fn update_alert_request_omits_none_fields() {
        // When a field is None, it should be omitted from the JSON body
        // so the API leaves that property unchanged.
        let req = UpdateAlertRequest {
            status: Some("InProgress".to_string()),
            assigned_to: None,
            classification: None,
            determination: None,
            comment: Some("Starting investigation".to_string()),
        };
        let json = serde_json::to_value(&req).unwrap();
        assert_eq!(json["status"], "InProgress");
        assert_eq!(json["comment"], "Starting investigation");
        assert!(json.get("assignedTo").is_none());
        assert!(json.get("classification").is_none());
        assert!(json.get("determination").is_none());
    }

    #[test]
    fn update_alert_request_comment_only() {
        // Adding just a comment without changing any other fields is a
        // valid use case for audit trail purposes.
        let req = UpdateAlertRequest {
            status: None,
            assigned_to: None,
            classification: None,
            determination: None,
            comment: Some("Reviewed, no action needed yet".to_string()),
        };
        let json = serde_json::to_value(&req).unwrap();
        assert_eq!(json["comment"], "Reviewed, no action needed yet");
        // Only the comment field should be present.
        let obj = json.as_object().unwrap();
        assert_eq!(obj.len(), 1, "only comment should be serialized");
    }

    // ── BatchUpdateAlertsRequest serialization ──────────────────────

    #[test]
    fn batch_update_request_serializes_with_ids_and_status() {
        let req = BatchUpdateAlertsRequest {
            alert_ids: vec!["alert-1".to_string(), "alert-2".to_string()],
            status: Some("Resolved".to_string()),
            assigned_to: None,
            classification: Some("FalsePositive".to_string()),
            determination: Some("NotMalicious".to_string()),
            comment: Some("Batch close — false positives".to_string()),
        };
        let json = serde_json::to_value(&req).unwrap();
        assert_eq!(json["alertIds"], serde_json::json!(["alert-1", "alert-2"]));
        assert_eq!(json["status"], "Resolved");
        assert_eq!(json["classification"], "FalsePositive");
        assert!(json.get("assignedTo").is_none());
    }

    #[test]
    fn batch_update_request_omits_optional_fields() {
        let req = BatchUpdateAlertsRequest {
            alert_ids: vec!["alert-3".to_string()],
            status: None,
            assigned_to: Some("soc@contoso.com".to_string()),
            classification: None,
            determination: None,
            comment: None,
        };
        let json = serde_json::to_value(&req).unwrap();
        assert_eq!(json["alertIds"], serde_json::json!(["alert-3"]));
        assert_eq!(json["assignedTo"], "soc@contoso.com");
        let obj = json.as_object().unwrap();
        assert_eq!(
            obj.len(),
            2,
            "only alertIds and assignedTo should be present"
        );
    }
}
